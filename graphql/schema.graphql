schema {
  query: Queries
  mutation: Mutations
}

type AccessToken implements Node {
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
}

# Autogenerated return type of AddCertificate
type AddCertificatePayload {
  app: App
  certificate: AppCertificate
  check: HostnameCheck
  errors: [String!]
}

# Autogenerated input type of AddWireGuardPeer
input AddWireGuardPeerInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The region in which to deploy the peer
  region: String

  # The name with which to refer to the peer
  name: String!

  # The 25519 public key for the peer
  pubkey: String!

  # Network ID to attach wireguard peer to
  network: String

  # Add via NATS transaction (deprecated - nats is always used)
  nats: Boolean
}

# Autogenerated return type of AddWireGuardPeer
type AddWireGuardPeerPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  endpointip: String!
  network: String
  peerip: String!
  pubkey: String!
}

# Autogenerated input type of AllocateIPAddress
input AllocateIPAddressInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The application to allocate the ip address for
  appId: ID!

  # The type of IP address to allocate (v4, v6, or private_v6)
  type: IPAddressType!

  # Desired IP region (defaults to global)
  region: String
}

# Autogenerated return type of AllocateIPAddress
type AllocateIPAddressPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  ipAddress: IPAddress!
}

type Allocation implements Node {
  attachedVolumes(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): VolumeConnection!
  canary: Boolean!
  checks(
    # Filter checks by name
    name: String
  ): [CheckState!]!
  createdAt: ISO8601DateTime!
  criticalCheckCount: Int!

  # Desired status
  desiredStatus: String!
  events: [AllocationEvent!]!
  failed: Boolean!
  healthy: Boolean!

  # Unique ID for this instance
  id: ID!

  # Short unique ID for this instance
  idShort: ID!

  # Indicates if this instance is from the latest job version
  latestVersion: Boolean!
  passingCheckCount: Int!

  # Private IPv6 address for this instance
  privateIP: String
  recentLogs(
    # Max number of entries to return
    limit: Int = 10

    # Max age of log entries in seconds
    range: Int = 300
  ): [LogEntry!]!

  # Region this allocation is running in
  region: String!
  restarts: Int!

  # Current status
  status: String!
  taskName: String!
  totalCheckCount: Int!
  transitioning: Boolean!
  updatedAt: ISO8601DateTime!

  # The configuration version of this instance
  version: Int!
  warningCheckCount: Int!
}

type AllocationEvent {
  message: String!
  timestamp: ISO8601DateTime!
  type: String!
}

type App implements Node {
  allocation(id: String!): Allocation
  allocations(showCompleted: Boolean): [Allocation!]!
  appUrl: String
  autoscaling: AutoscalingConfig
  backupRegions: [Region!]!

  # [DEPRECATED] Builds of this application
  builds(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): BuildConnection! @deprecated(reason: "Superseded by source_builds")

  # Find a certificate by hostname
  certificate(hostname: String!): AppCertificate

  # Certificates for this app
  certificates(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    filter: String
    id: String
  ): AppCertificateConnection!

  # Changes to this application
  changes(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AppChangeConnection!
  config: AppConfig!
  createdAt: ISO8601DateTime!
  currentPlacement: [RegionPlacement!]!

  # The latest release of this applicaion
  currentRelease: Release
  deployed: Boolean!

  # Continuous deployment configuration
  deploymentSource: DeploymentSource

  # Find a deployment by id, defaults to latest
  deploymentStatus(id: ID, evaluationId: String): DeploymentStatus

  # Check if this app has a configured deployment source
  hasDeploymentSource: Boolean!
  healthChecks(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int

    # Filter health checks by name
    name: String
  ): CheckStateConnection!

  # Autogenerated hostname for this application
  hostname: String

  # Unique application ID
  id: ID!

  # Resolve an image from a reference
  image(ref: String!): Image

  # Image details
  imageDetails: ImageVersion
  imageUpgradeAvailable: Boolean
  imageVersionTrackingEnabled: Boolean!

  # Authentication key to use with Instrumentation endpoints
  instrumentsKey: String
  internalId: String!
  internalNumericId: Int!

  # Find an ip address by address string
  ipAddress(address: String!): IPAddress
  ipAddresses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): IPAddressConnection!
  sharedIpAddress: String

  # This object's unique key
  key: String!

  # Latest image details
  latestImageDetails: ImageVersion
  machine(id: String!): Machine
  machines(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    version: Int
  ): MachineConnection!

  # The unique application name
  name: String!
  network: String

  # Organization that owns this app
  organization: Organization!
  parseConfig(definition: JSON!): AppConfig!

  # Fly platform version
  platformVersion: PlatformVersionEnum
  processGroups: [ProcessGroup!]!
  regions: [Region!]!

  # Find a specific release
  release(id: ID, version: Int): Release

  # Individual releases for this application
  releases(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): ReleaseConnection!
  role: AppRole

  # Application runtime
  runtime: RuntimeType!

  # Secrets set on the application
  secrets: [Secret!]!
  services: [Service!]!

  # Builds of this application
  sourceBuilds(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): SourceBuildConnection!
  state: AppState!

  # Application status
  status: String!
  taskGroupCounts: [TaskGroupCount!]!
  usage: [AppUsage!]!
  version: Int!
  vmSize: VMSize!
  vms(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    showCompleted: Boolean
  ): VMConnection!
  volume(internalId: String!): Volume

  # Volumes associated with app
  volumes(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): VolumeConnection!
}

type AppCertificate implements Node {
  acmeAlpnConfigured: Boolean! @deprecated(reason: "use isAcmeAlpnConfigured")
  acmeDnsConfigured: Boolean! @deprecated(reason: "use isAcmeDNSConfigured")
  certificateAuthority: String
  certificateRequestedAt: ISO8601DateTime
  check: Boolean!
  clientStatus: String!
  configured: Boolean! @deprecated(reason: "use isConfigured")
  createdAt: ISO8601DateTime
  dnsProvider: String
  dnsValidationHostname: String!
  dnsValidationInstructions: String!
  dnsValidationTarget: String!
  domain: String!
  hostname: String!
  id: ID!
  isAcmeAlpnConfigured: Boolean!
  isAcmeDnsConfigured: Boolean!
  isApex: Boolean!
  isConfigured: Boolean!
  isWildcard: Boolean!
  issued(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    includeExpired: Boolean
  ): CertificateConnection!
  source: String
  validationErrors: [AppCertificateValidationError!]!
}

# The connection type for AppCertificate.
type AppCertificateConnection {
  # A list of edges.
  edges: [AppCertificateEdge]

  # A list of nodes.
  nodes: [AppCertificate]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type AppCertificateEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AppCertificate
}

type AppCertificateValidationError {
  message: String!
  timestamp: ISO8601DateTime!
}

type AppChange implements Node {
  # Object that triggered the change
  actor: AppChangeActor
  actorType: String!
  app: App!
  createdAt: ISO8601DateTime!
  description: String!
  id: ID!
  status: String
  updatedAt: ISO8601DateTime!
  user: User
}

# Objects that change apps
union AppChangeActor = Build | Release | Secret

# The connection type for AppChange.
type AppChangeConnection {
  # A list of edges.
  edges: [AppChangeEdge]

  # A list of nodes.
  nodes: [AppChange]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type AppChangeEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: AppChange
}

type AppConfig {
  definition: JSON!
  errors: [String!]!
  services: [Service!]!
  valid: Boolean!
}

# The connection type for App.
type AppConnection {
  # A list of edges.
  edges: [AppEdge]

  # A list of nodes.
  nodes: [App]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type AppEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: App
}

interface AppRole {
  # The name of this role
  name: String!
}

enum AppState {
  # App has not been deployed
  PENDING

  # App has been deployed
  DEPLOYED

  # App has been suspended
  SUSPENDED
}

# Application usage data
type AppUsage {
  # The timespan interval for this usage sample
  interval: String!

  # Total requests for this time period
  requestsCount: Int!

  # Total app execution time (in seconds) for this time period
  totalAppExecS: Int!

  # Total GB transferred out in this time period
  totalDataOutGB: Float!

  # The start of the timespan for this usage sample
  ts: ISO8601DateTime!
}

# Autogenerated input type of AttachPostgresCluster
input AttachPostgresClusterInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The postgres cluster application id
  postgresClusterAppId: ID!

  # The application to attach postgres to
  appId: ID!

  # The database to attach. Defaults to a new database with the same name as the app.
  databaseName: String

  # The database user to create. Defaults to using the database name.
  databaseUser: String

  # The environment variable name to set the connection string to. Defaults to DATABASE_URL
  variableName: String

  # Flag used to indicate that flyctl will exec calls
  manualEntry: Boolean
}

# Autogenerated return type of AttachPostgresCluster
type AttachPostgresClusterPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  connectionString: String!
  environmentVariableName: String!
  postgresClusterApp: App!
}

type AutoscaleRegionConfig {
  # The region code
  code: String!

  # The minimum number of VMs to run in this region
  minCount: Int

  # The relative weight for this region
  weight: Int
}

# Region autoscaling configuration
input AutoscaleRegionConfigInput {
  # The region code to configure
  code: String!

  # The weight
  weight: Int

  # Minimum number of VMs to run in this region
  minCount: Int

  # Reset the configuration for this region
  reset: Boolean
}

enum AutoscaleStrategy {
  # autoscaling is disabled
  NONE

  # place vms in preferred regions by weight
  PREFERRED_REGIONS

  # place vms in regions near connection sources
  CONNECTION_SOURCES
}

type AutoscalingConfig {
  backupRegions: [String!]!
  balanceRegions: Boolean!
  enabled: Boolean!
  maxCount: Int!
  minCount: Int!
  preferredRegion: String
  regions: [AutoscaleRegionConfig!]!
  strategy: AutoscaleStrategy!
}

# Represents non-fractional signed whole numeric values. Since the value may exceed the size of a 32-bit integer, it's encoded as a string.
scalar BigInt

type Billable {
  app: App!
  category: String!
  product: String!
  quantity: Float!
  time: ISO8601DateTime!
}

# The connection type for Billable.
type BillableConnection {
  # A list of edges.
  edges: [BillableEdge]

  # A list of nodes.
  nodes: [Billable]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type BillableEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Billable
}

enum BillingStatus {
  CURRENT
  SOURCE_REQUIRED
  PAST_DUE
}

type Build implements Node {
  app: App!
  commitId: String
  commitUrl: String
  createdAt: ISO8601DateTime!

  # The user who initiated the build
  createdBy: User

  # Indicates if this build is complete and failed
  failed: Boolean!
  id: ID!
  image: String

  # Indicates if this build is currently in progress
  inProgress: Boolean!

  # Log output
  logs: String!
  number: Int!

  # Status of the build
  status: String!

  # Indicates if this build is complete and succeeded
  succeeded: Boolean!
  updatedAt: ISO8601DateTime!
}

# The connection type for Build.
type BuildConnection {
  # A list of edges.
  edges: [BuildEdge]

  # A list of nodes.
  nodes: [Build]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type BuildEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Build
}

# Autogenerated return type of CancelBuild
type CancelBuildPayload {
  build: Build!
}

type Certificate implements Node {
  expiresAt: ISO8601DateTime!
  hostname: String!
  id: ID!
  type: String!
}

# The connection type for Certificate.
type CertificateConnection {
  # A list of edges.
  edges: [CertificateEdge]

  # A list of nodes.
  nodes: [Certificate]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type CertificateEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Certificate
}

# health check
type Check {
  httpHeaders: [CheckHeader!]
  httpMethod: String
  httpPath: String
  httpProtocol: HTTPProtocol
  httpTlsSkipVerify: Boolean

  # Check interval in milliseconds
  interval: Int!
  name: String
  scriptArgs: [String!]
  scriptCommand: String

  # Check timeout in milliseconds
  timeout: Int!
  type: CheckType!
}

# Autogenerated input type of CheckCertificate
input CheckCertificateInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Application to ID
  appId: ID!

  # Certificate hostname to check
  hostname: String!
}

# Autogenerated return type of CheckCertificate
type CheckCertificatePayload {
  app: App
  certificate: AppCertificate
  check: HostnameCheck

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CheckDomain
input CheckDomainInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Domain name to check
  domainName: String!
}

# Autogenerated return type of CheckDomain
type CheckDomainPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dnsAvailable: Boolean!
  domainName: String!
  registrationAvailable: Boolean!
  registrationPeriod: Int
  registrationPrice: Int
  registrationSupported: Boolean!
  tld: String!
  transferAvailable: Boolean!
}

# check job http response
type CheckHTTPResponse implements Node {
  closeTs: String!
  connectedTs: String!
  dnsTs: String!
  firstTs: String!
  flyioDebug: JSON
  headers: JSON!
  id: ID!
  lastTs: String!
  location: CheckLocation!
  rawHeaders: String!
  rawOutput: [String!]!
  resolvedIp: String!
  sentTs: String!
  startTs: String!
  statusCode: Int!
  tlsTs: String
}

# The connection type for CheckHTTPResponse.
type CheckHTTPResponseConnection {
  # A list of edges.
  edges: [CheckHTTPResponseEdge]

  # A list of nodes.
  nodes: [CheckHTTPResponse]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type CheckHTTPResponseEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CheckHTTPResponse
}

# All available http checks verbs
enum CheckHTTPVerb {
  GET
  HEAD
}

# HTTP header for a health check
type CheckHeader {
  name: String!
  value: String!
}

input CheckHeaderInput {
  name: String!
  value: String!
}

input CheckInput {
  type: CheckType!
  name: String

  # Check interval in milliseconds
  interval: Int

  # Check timeout in milliseconds
  timeout: Int
  httpMethod: HTTPMethod
  httpPath: String
  httpProtocol: HTTPProtocol
  httpTlsSkipVerify: Boolean
  httpHeaders: [CheckHeaderInput!]
  scriptCommand: String
  scriptArgs: [String!]
}

# check job
type CheckJob implements Node {
  httpOptions: CheckJobHTTPOptions
  id: ID!
  locations(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CheckLocationConnection!
  nextRunAt: ISO8601DateTime
  runs(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CheckJobRunConnection!
  schedule: String
  url: String!
}

# The connection type for CheckJob.
type CheckJobConnection {
  # A list of edges.
  edges: [CheckJobEdge]

  # A list of nodes.
  nodes: [CheckJob]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type CheckJobEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CheckJob
}

# health check state
type CheckJobHTTPOptions {
  headers: [String!]!
  verb: CheckHTTPVerb!
}

# health check state
input CheckJobHTTPOptionsInput {
  verb: CheckHTTPVerb! = GET
  headers: [String!] = []
}

# check job run
type CheckJobRun implements Node {
  completedAt: ISO8601DateTime
  createdAt: ISO8601DateTime!
  httpOptions: CheckJobHTTPOptions!
  httpResponses(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CheckHTTPResponseConnection!
  id: ID!
  locations(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CheckLocationConnection!
  state: String!
  tests: [String!]!
  url: String!
}

# The connection type for CheckJobRun.
type CheckJobRunConnection {
  # A list of edges.
  edges: [CheckJobRunEdge]

  # A list of nodes.
  nodes: [CheckJobRun]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type CheckJobRunEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CheckJobRun
}

# check location
type CheckLocation {
  coordinates: [Float!]!
  country: String!
  locality: String!
  name: String!
  state: String
  title: String!
}

# The connection type for CheckLocation.
type CheckLocationConnection {
  # A list of edges.
  edges: [CheckLocationEdge]

  # A list of nodes.
  nodes: [CheckLocation]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type CheckLocationEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CheckLocation
}

# health check state
type CheckState {
  allocation: Allocation!
  allocationId: String!
  name: String!
  output(
    # The number of characters to truncate output to
    limit: Int

    # Remove newlines and trim whitespace
    compact: Boolean
  ): String!
  serviceName: String!
  status: String!
  type: CheckType!
  updatedAt: ISO8601DateTime!
}

# The connection type for CheckState.
type CheckStateConnection {
  # A list of edges.
  edges: [CheckStateEdge]

  # A list of nodes.
  nodes: [CheckState]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type CheckStateEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: CheckState
}

enum CheckType {
  # tcp health check
  TCP

  # http health check
  HTTP

  # script health check
  SCRIPT
}

# Autogenerated input type of ConfigureRegions
input ConfigureRegionsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # Regions to allow running in
  allowRegions: [String!]

  # Regions to deny running in
  denyRegions: [String!]

  # Fallback regions. Used if preferred regions are having issues
  backupRegions: [String!]

  # Process group to modify
  group: String
}

# Autogenerated return type of ConfigureRegions
type ConfigureRegionsPayload {
  app: App!
  backupRegions: [Region!]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  group: String
  regions: [Region!]!
}

# Autogenerated input type of CreateAndRegisterDomain
input CreateAndRegisterDomainInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The domain name
  name: String!

  # Enable whois privacy on the registration
  whoisPrivacy: Boolean

  # Enable auto renew on the registration
  autoRenew: Boolean
}

# Autogenerated return type of CreateAndRegisterDomain
type CreateAndRegisterDomainPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  domain: Domain!
  organization: Organization!
}

# Autogenerated input type of CreateAndTransferDomain
input CreateAndTransferDomainInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The domain name
  name: String!

  # The authorization code
  authorizationCode: String!
}

# Autogenerated return type of CreateAndTransferDomain
type CreateAndTransferDomainPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  domain: Domain!
  organization: Organization!
}

# Autogenerated input type of CreateApp
input CreateAppInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The application runtime
  runtime: RuntimeType = FIRECRACKER

  # The name of the new application. Defaults to a random name.
  name: String
  preferredRegion: String
  heroku: Boolean
  network: String
  appRoleId: String
  machines: Boolean = false
}

# Autogenerated return type of CreateApp
type CreateAppPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateCheckJob
input CreateCheckJobInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Organization ID
  organizationId: ID!

  # The URL to check
  url: String!

  # http checks locations
  locations: [String!]!

  # http check options
  httpOptions: CheckJobHTTPOptionsInput!
}

# Autogenerated return type of CreateCheckJob
type CreateCheckJobPayload {
  checkJob: CheckJob!
  checkJobRun: CheckJobRun

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateCheckJobRun
input CreateCheckJobRunInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Check Job ID
  checkJobId: ID!
}

# Autogenerated return type of CreateCheckJobRun
type CreateCheckJobRunPayload {
  checkJob: CheckJob!
  checkJobRun: CheckJobRun

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of CreateDNSPortal
input CreateDNSPortalInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The unique name of this portal. A random name will be generated if omitted.
  name: String

  # The title of this portal
  title: String

  # The return url for this portal
  returnUrl: String

  # The text to display for the return url link
  returnUrlText: String

  # The support url for this portal
  supportUrl: String

  # The text to display for the support url link
  supportUrlText: String

  # The primary branding color
  primaryColor: String

  # The secondary branding color
  accentColor: String
}

# Autogenerated return type of CreateDNSPortal
type CreateDNSPortalPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dnsPortal: DNSPortal!
}

# Autogenerated input type of CreateDNSPortalSession
input CreateDNSPortalSessionInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the dns portal
  dnsPortalId: ID!

  # The node ID of the domain to edit
  domainId: ID!

  # Optionally override the portal's default title for this session
  title: String

  # Optionally override the portal's default return url for this session
  returnUrl: String

  # Optionally override the portal's default return url text for this session
  returnUrlText: String
}

# Autogenerated return type of CreateDNSPortalSession
type CreateDNSPortalSessionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dnsPortalSession: DNSPortalSession!
}

# Autogenerated input type of CreateDNSRecord
input CreateDNSRecordInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the domain
  domainId: ID!

  # The type of the record
  type: DNSRecordType!

  # The dns record name
  name: String!

  # The TTL in seconds
  ttl: Int!

  # The content of the record
  rdata: String!
}

# Autogenerated return type of CreateDNSRecord
type CreateDNSRecordPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  record: DNSRecord!
}

# Autogenerated input type of CreateDelegatedWireGuardToken
input CreateDelegatedWireGuardTokenInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The name with which to refer to the peer
  name: String
}

# Autogenerated return type of CreateDelegatedWireGuardToken
type CreateDelegatedWireGuardTokenPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  token: String!
}

# Autogenerated input type of CreateDoctorReport
input CreateDoctorReportInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The report data
  data: JSON!
}

# Autogenerated return type of CreateDoctorReport
type CreateDoctorReportPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  reportId: ID!
}

# Autogenerated return type of CreateDoctorUrl
type CreateDoctorUrlPayload {
  putUrl: String!
}

# Autogenerated input type of CreateDomain
input CreateDomainInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The domain name
  name: String!
}

# Autogenerated return type of CreateDomain
type CreateDomainPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  domain: Domain!
  organization: Organization!
}

# Autogenerated input type of CreateOrganization
input CreateOrganizationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The name of the organization
  name: String!
}

# Autogenerated input type of CreateOrganizationInvitation
input CreateOrganizationInvitationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The email to invite
  email: String!
}

# Autogenerated return type of CreateOrganizationInvitation
type CreateOrganizationInvitationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  invitation: OrganizationInvitation!
}

# Autogenerated return type of CreateOrganization
type CreateOrganizationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  organization: Organization!
}

# Autogenerated input type of CreatePostgresClusterDatabase
input CreatePostgresClusterDatabaseInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The name of the postgres cluster app
  appName: String!

  # The name of the database
  databaseName: String!
}

# Autogenerated return type of CreatePostgresClusterDatabase
type CreatePostgresClusterDatabasePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  database: PostgresClusterDatabase!
  postgresClusterRole: PostgresClusterAppRole!
}

# Autogenerated input type of CreatePostgresCluster
input CreatePostgresClusterInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The name of the new application. Defaults to a random name.
  name: String
  region: String

  # The superuser password. Defaults to a random password.
  password: String

  # The VM size to use. Defaults to shared-cpu-1x
  vmSize: String = "shared-cpu-1x"

  # The volume size in GB. Defaults to 10.
  volumeSizeGb: Int = 10

  # Number of VM's to provision
  count: Int = 2
  imageRef: String
  snapshotId: ID
}

# Autogenerated return type of CreatePostgresCluster
type CreatePostgresClusterPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  password: String!
  username: String!
}

# Autogenerated input type of CreatePostgresClusterUser
input CreatePostgresClusterUserInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The name of the postgres cluster app
  appName: String!

  # The name of the database
  username: String!

  # The password of the user
  password: String!

  # Should this user be a superuser
  superuser: Boolean
}

# Autogenerated return type of CreatePostgresClusterUser
type CreatePostgresClusterUserPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  postgresClusterRole: PostgresClusterAppRole!
  user: PostgresClusterUser!
}

# Autogenerated input type of CreateTemplateDeployment
input CreateTemplateDeploymentInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization to move the app to
  organizationId: ID!
  template: JSON!
  variables: [PropertyInput!]
}

# Autogenerated return type of CreateTemplateDeployment
type CreateTemplateDeploymentPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  templateDeployment: TemplateDeployment!
}

# Autogenerated input type of CreateVolume
input CreateVolumeInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The application to attach the new volume to
  appId: ID!

  # Volume name
  name: String!

  # Desired region for volume
  region: String!

  # Desired volume size, in GB
  sizeGb: Int!

  # Volume should be encrypted at rest
  encrypted: Boolean

  # Provision volume in a redundancy zone not already in use by this app
  requireUniqueZone: Boolean
}

# Autogenerated return type of CreateVolume
type CreateVolumePayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  volume: Volume!
}

# Autogenerated input type of CreateVolumeSnapshot
input CreateVolumeSnapshotInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  volumeId: ID!
}

# Autogenerated return type of CreateVolumeSnapshot
type CreateVolumeSnapshotPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  volume: Volume!
}

type DNSPortal implements Node {
  accentColor: String!
  createdAt: ISO8601DateTime!
  id: ID!
  name: String!
  organiztion: Organization!
  primaryColor: String!
  returnUrl: String
  returnUrlText: String
  supportUrl: String
  supportUrlText: String
  title: String!
  updatedAt: ISO8601DateTime!
}

# The connection type for DNSPortal.
type DNSPortalConnection {
  # A list of edges.
  edges: [DNSPortalEdge]

  # A list of nodes.
  nodes: [DNSPortal]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type DNSPortalEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: DNSPortal
}

type DNSPortalSession implements Node {
  createdAt: ISO8601DateTime!

  # The dns portal this session
  dnsPortal: DNSPortal!
  expiresAt: ISO8601DateTime!
  id: ID!

  # Is this session expired?
  isExpired: Boolean!

  # The overridden return url for this session
  returnUrl: String

  # The overridden return url text for this session
  returnUrlText: String

  # The overridden title for this session
  title: String

  # The url to access this session's dns portal
  url: String!
}

type DNSRecord implements Node {
  createdAt: ISO8601DateTime!

  # The domain this record belongs to
  domain: Domain!

  # Fully qualified domain name for this record
  fqdn: String!
  id: ID!

  # Is this record at the zone apex?
  isApex: Boolean!

  # Is this a system record? System records are managed by fly and not editable.
  isSystem: Boolean!

  # Is this record a wildcard?
  isWildcard: Boolean!

  # The name of this record. @ indicates the record is at the zone apex.
  name: String!

  # The record data
  rdata: String!

  # The number of seconds this record can be cached for
  ttl: Int!

  # The type of record
  type: DNSRecordType!
  updatedAt: ISO8601DateTime!
}

type DNSRecordAttributes {
  # The name of the record.
  name: String!

  # The record data.
  rdata: String!

  # The number of seconds this record can be cached for.
  ttl: Int!

  # The type of record.
  type: DNSRecordType!
}

enum DNSRecordChangeAction {
  # A record should be created with the provided attributes
  CREATE

  # A record with the provided ID should be updated
  UPDATE

  # A record with the provided ID should be deleted
  DELETE
}

input DNSRecordChangeInput {
  # The action to perform on this record.
  action: DNSRecordChangeAction!

  # The id of the record this action will apply to. This is required if the action is UPDATE or DELETE.
  recordId: ID

  # The record type. This is required if action is CREATE.
  type: DNSRecordType

  # The name of the record. If omitted it will default to @ - the zone apex.
  name: String

  # The number of seconds this record can be cached for. Defaults to 1 hour.
  ttl: Int

  # The record data. Required if action is CREATE
  rdata: String
}

# The connection type for DNSRecord.
type DNSRecordConnection {
  # A list of edges.
  edges: [DNSRecordEdge]

  # A list of nodes.
  nodes: [DNSRecord]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

type DNSRecordDiff {
  # The action that was performed.
  action: DNSRecordChangeAction!

  # The attributes for this record after the action was performed.
  newAttributes: DNSRecordAttributes

  # The text representation of this record after the action was performed.
  newText: String

  # The attributes for this record before the action was performed.
  oldAttributes: DNSRecordAttributes

  # The text representation of this record before the action was performed.
  oldText: String
}

# An edge in a connection.
type DNSRecordEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: DNSRecord
}

enum DNSRecordType {
  A
  AAAA
  ALIAS
  CNAME
  MX
  NS
  SOA
  TXT
  SRV
}

type DNSRecordWarning {
  # The action to perform.
  action: DNSRecordChangeAction!

  # The desired attributes for this record.
  attributes: DNSRecordAttributes!

  # The warning message.
  message: String!

  # The record this warning applies to.
  record: DNSRecord
}

type DelegatedWireGuardToken implements Node {
  id: ID!
  name: String!
}

# The connection type for DelegatedWireGuardToken.
type DelegatedWireGuardTokenConnection {
  # A list of edges.
  edges: [DelegatedWireGuardTokenEdge]

  # A list of nodes.
  nodes: [DelegatedWireGuardToken]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type DelegatedWireGuardTokenEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: DelegatedWireGuardToken
}

# Autogenerated return type of DeleteApp
type DeleteAppPayload {
  # The organization that owned the deleted app
  organization: Organization!
}

# Autogenerated return type of DeleteCertificate
type DeleteCertificatePayload {
  app: App
  certificate: AppCertificate
  errors: [String!]
}

# Autogenerated input type of DeleteDNSPortal
input DeleteDNSPortalInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the dns portal
  dnsPortalId: ID!
}

# Autogenerated return type of DeleteDNSPortal
type DeleteDNSPortalPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The organization that owned the dns portal
  organization: Organization!
}

# Autogenerated input type of DeleteDNSPortalSession
input DeleteDNSPortalSessionInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the dns portal session
  dnsPortalSessionId: ID!
}

# Autogenerated return type of DeleteDNSPortalSession
type DeleteDNSPortalSessionPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The dns portal that owned the session
  dnsPortal: DNSPortal!
}

# Autogenerated input type of DeleteDNSRecord
input DeleteDNSRecordInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the DNS record
  recordId: ID!
}

# Autogenerated return type of DeleteDNSRecord
type DeleteDNSRecordPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  domain: Domain!
}

# Autogenerated input type of DeleteDelegatedWireGuardToken
input DeleteDelegatedWireGuardTokenInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The raw WireGuard token
  token: String

  # The name with which to refer to the token
  name: String
}

# Autogenerated return type of DeleteDelegatedWireGuardToken
type DeleteDelegatedWireGuardTokenPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  token: String!
}

# Autogenerated input type of DeleteDeploymentSource
input DeleteDeploymentSourceInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The application to update
  appId: String!
}

# Autogenerated return type of DeleteDeploymentSource
type DeleteDeploymentSourcePayload {
  app: App

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of DeleteDomain
input DeleteDomainInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the domain
  domainId: ID!
}

# Autogenerated return type of DeleteDomain
type DeleteDomainPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  organization: Organization!
}

# Autogenerated input type of DeleteHealthCheckHandler
input DeleteHealthCheckHandlerInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # Handler name
  name: String!
}

# Autogenerated return type of DeleteHealthCheckHandler
type DeleteHealthCheckHandlerPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of DeleteOrganization
input DeleteOrganizationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the organization to delete
  organizationId: ID!
}

# Autogenerated input type of DeleteOrganizationInvitation
input DeleteOrganizationInvitationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the invitation
  invitationId: ID!
}

# Autogenerated return type of DeleteOrganizationInvitation
type DeleteOrganizationInvitationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  organization: Organization!
}

# Autogenerated input type of DeleteOrganizationMembership
input DeleteOrganizationMembershipInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The node ID of the user
  userId: ID!
}

# Autogenerated return type of DeleteOrganizationMembership
type DeleteOrganizationMembershipPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  organization: Organization!
  user: User!
}

# Autogenerated return type of DeleteOrganization
type DeleteOrganizationPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  deletedOrganizationId: ID!
}

# Autogenerated input type of DeleteVolume
input DeleteVolumeInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the volume
  volumeId: ID!
}

# Autogenerated return type of DeleteVolume
type DeleteVolumePayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of DeployImage
input DeployImageInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # The image to deploy
  image: String!

  # Network services to expose
  services: [ServiceInput!]

  # app definition
  definition: JSON

  # The strategy for replacing existing instances. Defaults to canary.
  strategy: DeploymentStrategy
}

# Autogenerated return type of DeployImage
type DeployImagePayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  release: Release
  releaseCommand: ReleaseCommand
}

# Continuous deployment configuration
type DeploymentSource {
  backend: JSON!
  baseDir: String!
  connected: Boolean!
  id: ID!
  provider: String!

  # The ref to build from
  ref: String!
  repositoryId: String!

  # The repository to fetch source code from
  repositoryUrl: String!
}

type DeploymentStatus {
  allocations: [Allocation!]!
  description: String!
  desiredCount: Int!
  healthyCount: Int!

  # Unique ID for this deployment
  id: ID!
  inProgress: Boolean!
  placedCount: Int!
  promoted: Boolean!
  status: String!
  successful: Boolean!
  unhealthyCount: Int!
  version: Int!
}

enum DeploymentStrategy {
  # Deploy new instances all at once
  IMMEDIATE

  # Deploy new instances all at once
  SIMPLE

  # Incrementally replace old instances with new ones
  ROLLING

  # Ensure new instances are healthy before continuing with a rolling deployment
  CANARY

  # Launch all new instances before shutting down previous instances
  BLUEGREEN
}

# Autogenerated input type of DetachPostgresCluster
input DetachPostgresClusterInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The postgres cluster application id
  postgresClusterAppId: ID!

  # The application to detach postgres from
  appId: ID!

  # The postgres attachment id
  postgresClusterAttachmentId: ID
}

# Autogenerated return type of DetachPostgresCluster
type DetachPostgresClusterPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  postgresClusterApp: App!
}

type Domain implements Node {
  autoRenew: Boolean
  createdAt: ISO8601DateTime!

  # The delegated nameservers for the registration
  delegatedNameservers: [String!]

  # The dns records for this domain
  dnsRecords(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): DNSRecordConnection!
  dnsStatus: DomainDNSStatus!
  expiresAt: ISO8601DateTime
  id: ID!

  # The name for this domain
  name: String!

  # The organization that owns this domain
  organization: Organization!
  registrationStatus: DomainRegistrationStatus!
  updatedAt: ISO8601DateTime!

  # The nameservers for the hosted zone
  zoneNameservers: [String!]!
}

# The connection type for Domain.
type DomainConnection {
  # A list of edges.
  edges: [DomainEdge]

  # A list of nodes.
  nodes: [Domain]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

enum DomainDNSStatus {
  # The DNS zone has not been created yet
  PENDING

  # The DNS zone is being updated
  UPDATING

  # The DNS zone is ready
  READY
}

# An edge in a connection.
type DomainEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Domain
}

enum DomainRegistrationStatus {
  # The domain is not registered on fly
  UNMANAGED

  # The domain is being registered
  REGISTERING

  # The domain is registered
  REGISTERED

  # The domain is being transferred
  TRANSFERRING

  # The domain registration has expired
  EXPIRED
}

# Autogenerated input type of DummyWireGuardPeer
input DummyWireGuardPeerInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The region in which to deploy the peer
  region: String
}

# Autogenerated return type of DummyWireGuardPeer
type DummyWireGuardPeerPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  endpointip: String!
  localpub: String!
  peerip: String!
  privkey: String!
  pubkey: String!
}

type EmptyAppRole implements AppRole {
  # The name of this role
  name: String!
}

# Autogenerated input type of EnablePostgresConsul
input EnablePostgresConsulInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID
}

# Autogenerated return type of EnablePostgresConsul
type EnablePostgresConsulPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  consulUrl: String!
}

# Autogenerated input type of EnsureMachineRemoteBuilder
input EnsureMachineRemoteBuilderInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The unique application name
  appName: String

  # The node ID of the organization
  organizationId: ID

  # Desired region for the remote builder
  region: String

  # Use v2 machines
  v2: Boolean
}

# Autogenerated return type of EnsureMachineRemoteBuilder
type EnsureMachineRemoteBuilderPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  machine: Machine!
}

# Autogenerated input type of EstablishSSHKey
input EstablishSSHKeyInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # Establish a key even if one is already set
  override: Boolean
}

# Autogenerated return type of EstablishSSHKey
type EstablishSSHKeyPayload {
  certificate: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of ExportDNSZone
input ExportDNSZoneInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # ID of the domain to export
  domainId: ID!
}

# Autogenerated return type of ExportDNSZone
type ExportDNSZonePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  contents: String!
  domain: Domain!
}

type FlyPlatform {
  # Latest flyctl release details
  flyctl: FlyctlRelease!

  # Fly global regions
  regions: [Region!]!

  # Region current request from
  requestRegion: String

  # Available VM sizes
  vmSizes: [VMSize!]!
}

type FlyctlMachineHostAppRole implements AppRole {
  # The name of this role
  name: String!
}

type FlyctlRelease {
  timestamp: ISO8601DateTime!
  version: String!
}

type GithubAppInstallation {
  editUrl: String!
  id: ID!
  owner: String!
  repositories: [GithubRepository!]!
}

type GithubIntegration {
  installationUrl: String!
  installations: [GithubAppInstallation!]!
  viewerAuthenticated: Boolean!
}

type GithubRepository {
  fork: Boolean!
  fullName: String!
  id: String!
  name: String!
  private: Boolean!
}

# Autogenerated input type of GrantPostgresClusterUserAccess
input GrantPostgresClusterUserAccessInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The name of the postgres cluster app
  appName: String!

  # The name of the database
  username: String!

  # The database to grant access to
  databaseName: String!
}

# Autogenerated return type of GrantPostgresClusterUserAccess
type GrantPostgresClusterUserAccessPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  database: PostgresClusterDatabase!
  postgresClusterRole: PostgresClusterAppRole!
  user: PostgresClusterUser!
}

enum HTTPMethod {
  GET
  POST
  PUT
  PATCH
  HEAD
  DELETE
}

enum HTTPProtocol {
  # HTTP protocol
  HTTP

  # HTTPS protocol
  HTTPS
}

type HealthCheck {
  # Raw name of entity
  entity: String!

  # Time check last passed
  lastPassing: ISO8601DateTime

  # Check name
  name: String!

  # Latest check output
  output: String

  # Current check state
  state: String!
}

# The connection type for HealthCheck.
type HealthCheckConnection {
  # A list of edges.
  edges: [HealthCheckEdge]

  # A list of nodes.
  nodes: [HealthCheck]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type HealthCheckEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: HealthCheck
}

type HealthCheckHandler {
  # Handler name
  name: String!

  # Handler type (Slack or Pagerduty)
  type: String!
}

# The connection type for HealthCheckHandler.
type HealthCheckHandlerConnection {
  # A list of edges.
  edges: [HealthCheckHandlerEdge]

  # A list of nodes.
  nodes: [HealthCheckHandler]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type HealthCheckHandlerEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: HealthCheckHandler
}

type HerokuApp {
  id: String!
  name: String!
  region: String
  releasedAt: ISO8601DateTime!
  stack: String
  teamName: String
}

type HerokuIntegration {
  herokuApps: [HerokuApp!]!
  viewerAuthenticated: Boolean!
}

type Host implements Node {
  id: ID!
}

type HostnameCheck {
  aRecords: [String!]!
  aaaaRecords: [String!]!
  acmeDnsConfigured: Boolean!
  caaRecords: [String!]!
  cnameRecords: [String!]!
  dnsConfigured: Boolean!
  dnsProvider: String
  dnsVerificationRecord: String
  errors: [String!]
  id: ID!
  isProxied: Boolean!
  resolvedAddresses: [String!]!
  soa: String
}

type IPAddress implements Node {
  address: String!
  createdAt: ISO8601DateTime!
  id: ID!
  region: String
  type: IPAddressType!
}

# The connection type for IPAddress.
type IPAddressConnection {
  # A list of edges.
  edges: [IPAddressEdge]

  # A list of nodes.
  nodes: [IPAddress]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type IPAddressEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: IPAddress
}

enum IPAddressType {
  v4
  v6
  private_v6
}

# An ISO 8601-encoded datetime
scalar ISO8601DateTime

type Image {
  absoluteRef: String!
  compressedSize: Int!
  config: JSON!
  configDigest: JSON!
  createdAt: ISO8601DateTime!
  digest: String!
  id: ID!
  label: String!
  manifest: JSON!
  ref: String!
  registry: String!
  repository: String!
  tag: String
}

type ImageVersion {
  digest: String!
  registry: String!
  repository: String!
  tag: String!
  version: String
}

# Autogenerated return type of ImportCertificate
type ImportCertificatePayload {
  app: App
  appCertificate: AppCertificate
  certificate: Certificate
  errors: [String!]
}

# Autogenerated input type of ImportDNSZone
input ImportDNSZoneInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # ID of the domain to export
  domainId: ID!
  zonefile: String!
}

# Autogenerated return type of ImportDNSZone
type ImportDNSZonePayload {
  changes: [DNSRecordDiff!]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  domain: Domain!
  warnings: [DNSRecordWarning!]!
}

# Autogenerated input type of IssueCertificate
input IssueCertificateInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # Email address of user to be issued certificate
  email: String!

  # Unix username valid for certificate
  username: String

  # Hours for which certificate will be valid
  validHours: Int

  # Comma-separated list of SSH principals for certificate
  principals: String
}

# Autogenerated return type of IssueCertificate
type IssueCertificatePayload {
  certificate: String!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  key: String!
}

# Untyped JSON data
scalar JSON

# Autogenerated input type of KillMachine
input KillMachineInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID

  # machine id
  id: String!
}

# Autogenerated return type of KillMachine
type KillMachinePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  machine: Machine!
}

# Autogenerated input type of LaunchApp
input LaunchAppInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # App name to create
  name: String

  # Configuration
  config: JSON

  # Size of VM for your app
  vmSize: VMSizeEnum

  # Regions to launch your app to
  regions: [String!]

  # Number of instances to run
  count: Int

  # Volumes to create
  volumes: [VolumeInput!]

  # Secrets to set
  secrets: [SecretInput!]

  # Type of scheduling for this app
  scheduling: SchedulingEnum

  # Docker image to launch
  image: String!
}

# Autogenerated return type of LaunchApp
type LaunchAppPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  release: Release
}

# Autogenerated input type of LaunchMachine
input LaunchMachineInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID

  # The node ID of the organization
  organizationId: ID

  # The ID of the machine
  id: String

  # The name of the machine
  name: String

  # Region for the machine
  region: String

  # Configuration
  config: JSON!
}

# Autogenerated return type of LaunchMachine
type LaunchMachinePayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  machine: Machine!
}

type LogEntry {
  id: String!
  instanceId: String!
  level: String!
  message: String!
  region: String!
  timestamp: ISO8601DateTime!
}

type LoggedCertificate implements Node {
  cert: String!
  id: ID!
  root: Boolean!
}

# The connection type for LoggedCertificate.
type LoggedCertificateConnection {
  # A list of edges.
  edges: [LoggedCertificateEdge]

  # A list of nodes.
  nodes: [LoggedCertificate]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type LoggedCertificateEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: LoggedCertificate
}

type Machine implements Node {
  app: App!
  config: JSON!
  createdAt: ISO8601DateTime!
  events(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    kind: String
  ): MachineEventConnection!
  host: Host!
  id: ID!
  instanceId: String!
  ips(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): MachineIPConnection!
  name: String!
  region: String!
  state: String!
  updatedAt: ISO8601DateTime!
}

# The connection type for Machine.
type MachineConnection {
  # A list of edges.
  edges: [MachineEdge]

  # A list of nodes.
  nodes: [Machine]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type MachineEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Machine
}

# A machine state change event
interface MachineEvent {
  id: ID!
  kind: String!
  timestamp: ISO8601DateTime!
}

# The connection type for MachineEvent.
type MachineEventConnection {
  # A list of edges.
  edges: [MachineEventEdge]

  # A list of nodes.
  nodes: [MachineEvent]

  # Information to aid in pagination.
  pageInfo: PageInfo!
}

type MachineEventDestroy implements MachineEvent {
  id: ID!
  kind: String!
  timestamp: ISO8601DateTime!
}

# An edge in a connection.
type MachineEventEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: MachineEvent
}

type MachineEventExit implements MachineEvent {
  exitCode: Int!
  id: ID!
  kind: String!
  metadata: JSON!
  oomKilled: Boolean!
  requestedStop: Boolean!
  timestamp: ISO8601DateTime!
}

type MachineEventGeneric implements MachineEvent {
  id: ID!
  kind: String!
  timestamp: ISO8601DateTime!
}

type MachineEventStart implements MachineEvent {
  id: ID!
  kind: String!
  timestamp: ISO8601DateTime!
}

type MachineIP implements Node {
  family: String!

  # ID of the object.
  id: ID!
  ip: String!
  kind: String!
  maskSize: Int!
}

# The connection type for MachineIP.
type MachineIPConnection {
  # A list of edges.
  edges: [MachineIPEdge]

  # A list of nodes.
  nodes: [MachineIP]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type MachineIPEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: MachineIP
}

# Autogenerated input type of MoveApp
input MoveAppInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The application to move
  appId: ID!

  # The node ID of the organization to move the app to
  organizationId: ID!
}

# Autogenerated return type of MoveApp
type MoveAppPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

type Mutations {
  addCertificate(
    # The application to attach the new hostname to
    appId: ID!

    # Certificate's hostname
    hostname: String!
  ): AddCertificatePayload
  addWireGuardPeer(
    # Parameters for AddWireGuardPeer
    input: AddWireGuardPeerInput!
  ): AddWireGuardPeerPayload
  allocateIpAddress(
    # Parameters for AllocateIPAddress
    input: AllocateIPAddressInput!
  ): AllocateIPAddressPayload
  attachPostgresCluster(
    # Parameters for AttachPostgresCluster
    input: AttachPostgresClusterInput!
  ): AttachPostgresClusterPayload
  cancelBuild(
    # The node ID of the build
    buildId: ID!
  ): CancelBuildPayload
  checkCertificate(
    # Parameters for CheckCertificate
    input: CheckCertificateInput!
  ): CheckCertificatePayload
  checkDomain(
    # Parameters for CheckDomain
    input: CheckDomainInput!
  ): CheckDomainPayload
  configureRegions(
    # Parameters for ConfigureRegions
    input: ConfigureRegionsInput!
  ): ConfigureRegionsPayload
  createAndRegisterDomain(
    # Parameters for CreateAndRegisterDomain
    input: CreateAndRegisterDomainInput!
  ): CreateAndRegisterDomainPayload
  createAndTransferDomain(
    # Parameters for CreateAndTransferDomain
    input: CreateAndTransferDomainInput!
  ): CreateAndTransferDomainPayload
  createApp(
    # Parameters for CreateApp
    input: CreateAppInput!
  ): CreateAppPayload
  createCheckJob(
    # Parameters for CreateCheckJob
    input: CreateCheckJobInput!
  ): CreateCheckJobPayload
  createCheckJobRun(
    # Parameters for CreateCheckJobRun
    input: CreateCheckJobRunInput!
  ): CreateCheckJobRunPayload
  createDelegatedWireGuardToken(
    # Parameters for CreateDelegatedWireGuardToken
    input: CreateDelegatedWireGuardTokenInput!
  ): CreateDelegatedWireGuardTokenPayload
  createDnsPortal(
    # Parameters for CreateDNSPortal
    input: CreateDNSPortalInput!
  ): CreateDNSPortalPayload
  createDnsPortalSession(
    # Parameters for CreateDNSPortalSession
    input: CreateDNSPortalSessionInput!
  ): CreateDNSPortalSessionPayload
  createDnsRecord(
    # Parameters for CreateDNSRecord
    input: CreateDNSRecordInput!
  ): CreateDNSRecordPayload
  createDoctorReport(
    # Parameters for CreateDoctorReport
    input: CreateDoctorReportInput!
  ): CreateDoctorReportPayload
  createDoctorUrl: CreateDoctorUrlPayload
  createDomain(
    # Parameters for CreateDomain
    input: CreateDomainInput!
  ): CreateDomainPayload
  createOrganization(
    # Parameters for CreateOrganization
    input: CreateOrganizationInput!
  ): CreateOrganizationPayload
  createOrganizationInvitation(
    # Parameters for CreateOrganizationInvitation
    input: CreateOrganizationInvitationInput!
  ): CreateOrganizationInvitationPayload
  createPostgresCluster(
    # Parameters for CreatePostgresCluster
    input: CreatePostgresClusterInput!
  ): CreatePostgresClusterPayload
  createPostgresClusterDatabase(
    # Parameters for CreatePostgresClusterDatabase
    input: CreatePostgresClusterDatabaseInput!
  ): CreatePostgresClusterDatabasePayload
  createPostgresClusterUser(
    # Parameters for CreatePostgresClusterUser
    input: CreatePostgresClusterUserInput!
  ): CreatePostgresClusterUserPayload
  createTemplateDeployment(
    # Parameters for CreateTemplateDeployment
    input: CreateTemplateDeploymentInput!
  ): CreateTemplateDeploymentPayload
  createVolume(
    # Parameters for CreateVolume
    input: CreateVolumeInput!
  ): CreateVolumePayload
  createVolumeSnapshot(
    # Parameters for CreateVolumeSnapshot
    input: CreateVolumeSnapshotInput!
  ): CreateVolumeSnapshotPayload

  # Delete an app
  deleteApp(
    # The application to delete
    appId: ID!
  ): DeleteAppPayload
  deleteCertificate(
    # Application to remove hostname from
    appId: ID!

    # Certificate hostname to delete
    hostname: String!
  ): DeleteCertificatePayload
  deleteDelegatedWireGuardToken(
    # Parameters for DeleteDelegatedWireGuardToken
    input: DeleteDelegatedWireGuardTokenInput!
  ): DeleteDelegatedWireGuardTokenPayload
  deleteDeploymentSource(
    # Parameters for DeleteDeploymentSource
    input: DeleteDeploymentSourceInput!
  ): DeleteDeploymentSourcePayload
  deleteDnsPortal(
    # Parameters for DeleteDNSPortal
    input: DeleteDNSPortalInput!
  ): DeleteDNSPortalPayload
  deleteDnsPortalSession(
    # Parameters for DeleteDNSPortalSession
    input: DeleteDNSPortalSessionInput!
  ): DeleteDNSPortalSessionPayload
  deleteDnsRecord(
    # Parameters for DeleteDNSRecord
    input: DeleteDNSRecordInput!
  ): DeleteDNSRecordPayload
  deleteDomain(
    # Parameters for DeleteDomain
    input: DeleteDomainInput!
  ): DeleteDomainPayload
  deleteHealthCheckHandler(
    # Parameters for DeleteHealthCheckHandler
    input: DeleteHealthCheckHandlerInput!
  ): DeleteHealthCheckHandlerPayload
  deleteOrganization(
    # Parameters for DeleteOrganization
    input: DeleteOrganizationInput!
  ): DeleteOrganizationPayload
  deleteOrganizationInvitation(
    # Parameters for DeleteOrganizationInvitation
    input: DeleteOrganizationInvitationInput!
  ): DeleteOrganizationInvitationPayload
  deleteOrganizationMembership(
    # Parameters for DeleteOrganizationMembership
    input: DeleteOrganizationMembershipInput!
  ): DeleteOrganizationMembershipPayload
  deleteVolume(
    # Parameters for DeleteVolume
    input: DeleteVolumeInput!
  ): DeleteVolumePayload
  deployImage(
    # Parameters for DeployImage
    input: DeployImageInput!
  ): DeployImagePayload
  detachPostgresCluster(
    # Parameters for DetachPostgresCluster
    input: DetachPostgresClusterInput!
  ): DetachPostgresClusterPayload
  dummyWireGuardPeer(
    # Parameters for DummyWireGuardPeer
    input: DummyWireGuardPeerInput!
  ): DummyWireGuardPeerPayload
  enablePostgresConsul(
    # Parameters for EnablePostgresConsul
    input: EnablePostgresConsulInput!
  ): EnablePostgresConsulPayload
  ensureMachineRemoteBuilder(
    # Parameters for EnsureMachineRemoteBuilder
    input: EnsureMachineRemoteBuilderInput!
  ): EnsureMachineRemoteBuilderPayload
  establishSshKey(
    # Parameters for EstablishSSHKey
    input: EstablishSSHKeyInput!
  ): EstablishSSHKeyPayload
  exportDnsZone(
    # Parameters for ExportDNSZone
    input: ExportDNSZoneInput!
  ): ExportDNSZonePayload
  grantPostgresClusterUserAccess(
    # Parameters for GrantPostgresClusterUserAccess
    input: GrantPostgresClusterUserAccessInput!
  ): GrantPostgresClusterUserAccessPayload
  importCertificate(
    # The application to attach the new hostname to
    appId: ID!

    # Full chain for certificate
    fullchain: String!

    # Private signing key for certificate
    privateKey: String!

    # Hostname for certificate (certificate Common Name by default)
    hostname: String
  ): ImportCertificatePayload
  importDnsZone(
    # Parameters for ImportDNSZone
    input: ImportDNSZoneInput!
  ): ImportDNSZonePayload
  issueCertificate(
    # Parameters for IssueCertificate
    input: IssueCertificateInput!
  ): IssueCertificatePayload
  killMachine(
    # Parameters for KillMachine
    input: KillMachineInput!
  ): KillMachinePayload
  launchApp(
    # Parameters for LaunchApp
    input: LaunchAppInput!
  ): LaunchAppPayload
  launchMachine(
    # Parameters for LaunchMachine
    input: LaunchMachineInput!
  ): LaunchMachinePayload
  moveApp(
    # Parameters for MoveApp
    input: MoveAppInput!
  ): MoveAppPayload
  pauseApp(
    # Parameters for PauseApp
    input: PauseAppInput!
  ): PauseAppPayload
  registerDomain(
    # Parameters for RegisterDomain
    input: RegisterDomainInput!
  ): RegisterDomainPayload
  releaseIpAddress(
    # Parameters for ReleaseIPAddress
    input: ReleaseIPAddressInput!
  ): ReleaseIPAddressPayload
  removeMachine(
    # Parameters for RemoveMachine
    input: RemoveMachineInput!
  ): RemoveMachinePayload
  removeWireGuardPeer(
    # Parameters for RemoveWireGuardPeer
    input: RemoveWireGuardPeerInput!
  ): RemoveWireGuardPeerPayload
  restartAllocation(
    # Parameters for RestartAllocation
    input: RestartAllocationInput!
  ): RestartAllocationPayload
  restartApp(
    # Parameters for RestartApp
    input: RestartAppInput!
  ): RestartAppPayload
  restoreVolumeSnapshot(
    # Parameters for RestoreVolumeSnapshot
    input: RestoreVolumeSnapshotInput!
  ): RestoreVolumeSnapshotPayload
  resumeApp(
    # Parameters for ResumeApp
    input: ResumeAppInput!
  ): ResumeAppPayload
  revokePostgresClusterUserAccess(
    # Parameters for RevokePostgresClusterUserAccess
    input: RevokePostgresClusterUserAccessInput!
  ): RevokePostgresClusterUserAccessPayload
  saveDeploymentSource(
    # Parameters for SaveDeploymentSource
    input: SaveDeploymentSourceInput!
  ): SaveDeploymentSourcePayload
  scaleApp(
    # Parameters for ScaleApp
    input: ScaleAppInput!
  ): ScaleAppPayload
  setPagerdutyHandler(
    # Parameters for SetPagerdutyHandler
    input: SetPagerdutyHandlerInput!
  ): SetPagerdutyHandlerPayload
  setSecrets(
    # Parameters for SetSecrets
    input: SetSecretsInput!
  ): SetSecretsPayload
  setSlackHandler(
    # Parameters for SetSlackHandler
    input: SetSlackHandlerInput!
  ): SetSlackHandlerPayload
  setVmCount(
    # Parameters for SetVMCount
    input: SetVMCountInput!
  ): SetVMCountPayload
  setVmSize(
    # Parameters for SetVMSize
    input: SetVMSizeInput!
  ): SetVMSizePayload
  startBuild(
    # Parameters for StartBuild
    input: StartBuildInput!
  ): StartBuildPayload
  startMachine(
    # Parameters for StartMachine
    input: StartMachineInput!
  ): StartMachinePayload
  stopAllocation(
    # Parameters for StopAllocation
    input: StopAllocationInput!
  ): StopAllocationPayload
  stopMachine(
    # Parameters for StopMachine
    input: StopMachineInput!
  ): StopMachinePayload
  unsetSecrets(
    # Parameters for UnsetSecrets
    input: UnsetSecretsInput!
  ): UnsetSecretsPayload
  updateAutoscaleConfig(
    # Parameters for UpdateAutoscaleConfig
    input: UpdateAutoscaleConfigInput!
  ): UpdateAutoscaleConfigPayload
  updateBuild(
    # Parameters for UpdateBuild
    input: UpdateBuildInput!
  ): UpdateBuildPayload
  updateDnsPortal(
    # Parameters for UpdateDNSPortal
    input: UpdateDNSPortalInput!
  ): UpdateDNSPortalPayload
  updateDnsRecord(
    # Parameters for UpdateDNSRecord
    input: UpdateDNSRecordInput!
  ): UpdateDNSRecordPayload
  updateDnsRecords(
    # Parameters for UpdateDNSRecords
    input: UpdateDNSRecordsInput!
  ): UpdateDNSRecordsPayload
  updateOrganizationMembership(
    # Parameters for UpdateOrganizationMembership
    input: UpdateOrganizationMembershipInput!
  ): UpdateOrganizationMembershipPayload
  updateRemoteBuilder(
    # Parameters for UpdateRemoteBuilder
    input: UpdateRemoteBuilderInput!
  ): UpdateRemoteBuilderPayload
  validateWireGuardPeers(
    # Parameters for ValidateWireGuardPeers
    input: ValidateWireGuardPeersInput!
  ): ValidateWireGuardPeersPayload
}

# An object with an ID.
interface Node {
  # ID of the object.
  id: ID!
}

type Organization implements Node {
  activeDiscountName: String
  apps(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AppConnection!
  billables(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    startDate: ISO8601DateTime!
    endDate: ISO8601DateTime!

    # Filter for app
    appId: ID
  ): BillableConnection!
  billingStatus: BillingStatus!

  # The account credits in cents
  creditBalance: Int!

  # The formatted account credits
  creditBalanceFormatted: String!
  delegatedWireGuardTokens(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): DelegatedWireGuardTokenConnection!

  # Find a dns portal by name
  dnsPortal(name: String!): DNSPortal!
  dnsPortals(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): DNSPortalConnection!

  # Find a domain by name
  domain(name: String!): Domain
  domains(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): DomainConnection!
  healthCheckHandlers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): HealthCheckHandlerConnection!
  healthChecks(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): HealthCheckConnection!
  id: ID!
  internalNumericId: BigInt!
  invitations(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): OrganizationInvitationConnection!
  isCreditCardSaved: Boolean!
  loggedCertificates(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): LoggedCertificateConnection
  members(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): OrganizationMembershipsConnection!

  # Organization name
  name: String!
  remoteBuilderApp: App
  remoteBuilderImage: String!
  settings: JSON

  # Unique organization slug
  slug: String!
  sshCertificate: String
  trust: OrganizationTrust!

  # The type of organization
  type: OrganizationType!

  # The current user's role in the org
  viewerRole: String!

  # Find a peer by name
  wireGuardPeer(name: String!): WireGuardPeer!
  wireGuardPeers(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): WireGuardPeerConnection!
}

# The connection type for Organization.
type OrganizationConnection {
  # A list of edges.
  edges: [OrganizationEdge]

  # A list of nodes.
  nodes: [Organization]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type OrganizationEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Organization
}

type OrganizationInvitation implements Node {
  createdAt: ISO8601DateTime!
  email: String!
  id: ID!

  # The user who created the invitation
  inviter: User!
  organization: Organization!
  redeemed: Boolean!
  redeemedAt: ISO8601DateTime
}

# The connection type for OrganizationInvitation.
type OrganizationInvitationConnection {
  # A list of edges.
  edges: [OrganizationInvitationEdge]

  # A list of nodes.
  nodes: [OrganizationInvitation]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type OrganizationInvitationEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: OrganizationInvitation
}

enum OrganizationMemberRole {
  # The user is an administrator of the organization
  ADMIN

  # The user is a member of the organization
  MEMBER
}

# The connection type for User.
type OrganizationMembershipsConnection {
  # A list of edges.
  edges: [OrganizationMembershipsEdge]

  # A list of nodes.
  nodes: [User]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type OrganizationMembershipsEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The date the user joined the organization
  joinedAt: ISO8601DateTime!

  # The item at the end of the edge.
  node: User

  # The role the user has in this organization
  role: OrganizationMemberRole!
}

enum OrganizationTrust {
  # We haven't set a trust level yet
  UNKNOWN

  # Organization has limited access to our service
  RESTRICTED

  # Organization cannot use our services
  BANNED

  # Organization has to prove that is not fraud over time but can use our services
  LOW

  # Organization proved that it's safe to use our services
  HIGH
}

enum OrganizationType {
  # A user's personal organization
  PERSONAL

  # An organization shared between one or more users
  SHARED
}

# Information about pagination in a connection.
type PageInfo {
  # When paginating forwards, the cursor to continue.
  endCursor: String

  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String
}

# Autogenerated input type of PauseApp
input PauseAppInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!
}

# Autogenerated return type of PauseApp
type PauseAppPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

enum PlatformVersionEnum {
  # Nomad managed application
  nomad

  # App with only machines
  machines
}

type PostgresClusterAppRole implements AppRole {
  databases: [PostgresClusterDatabase!]!

  # The name of this role
  name: String!
  users: [PostgresClusterUser!]!
}

type PostgresClusterAttachment implements Node {
  databaseName: String!
  databaseUser: String!
  environmentVariableName: String!
  id: ID!
}

# The connection type for PostgresClusterAttachment.
type PostgresClusterAttachmentConnection {
  # A list of edges.
  edges: [PostgresClusterAttachmentEdge]

  # A list of nodes.
  nodes: [PostgresClusterAttachment]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type PostgresClusterAttachmentEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: PostgresClusterAttachment
}

type PostgresClusterDatabase {
  name: String!
  users: [String!]!
}

type PostgresClusterUser {
  databases: [String!]!
  isSuperuser: Boolean!
  username: String!
}

type PriceTier {
  unitAmount: String
  upTo: BigInt
}

type ProcessGroup {
  maxPerRegion: Int!
  name: String!
  regions: [String!]!
  vmSize: VMSize!
}

type Product {
  name: String!
  tiers: [PriceTier!]!
  type: String!
  unitLabel: String
}

input PropertyInput {
  # The name of the property
  name: String!

  # The value of the property
  value: String
}

type Queries {
  # Find an app by name
  app(name: String, internalId: String): App

  # List apps
  apps(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    active: Boolean
    role: String
  ): AppConnection!

  # Find a certificate by ID
  certificate(id: ID!): AppCertificate
  checkJobs(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): CheckJobConnection!
  checkLocations: [CheckLocation!]!
  currentUser: User! @deprecated(reason: "use viewer instead")

  # Find a domain by name
  domain(name: String!): Domain
  githubIntegration: GithubIntegration! @deprecated(reason: "deprecated")
  herokuIntegration: HerokuIntegration!

  # Find an ip address by ID
  ipAddress(id: ID!): IPAddress

  # Returns the latest available tag for a given image repository
  latestImageDetails(
    # <repositry>/<name>:<tag>
    image: String!
  ): ImageVersion!

  # Returns the latest available tag for a given image repository
  latestImageTag(repository: String!): String!

  # Get a single machine
  machine(machineId: String!): Machine!

  # List machines
  machines(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    appId: String
    state: String
    version: Int
  ): MachineConnection!
  nearestRegion(wireguardGateway: Boolean): Region!

  # Fetches an object given its ID.
  node(
    # ID of the object.
    id: ID!
  ): Node

  # Fetches a list of objects given a list of IDs.
  nodes(
    # IDs of the objects.
    ids: [ID!]!
  ): [Node]!

  # Find an organization by ID
  organization(id: ID, name: String, slug: String): Organization
  organizations(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    withBillingIssuesOnly: Boolean
    admin: Boolean
    type: OrganizationType
  ): OrganizationConnection!
  personalOrganization: Organization!

  # fly.io platform information
  platform: FlyPlatform!

  # List postgres attachments
  postgresAttachments(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
    appName: String!
    postgresAppName: String!
  ): PostgresClusterAttachmentConnection!

  # Fly.io product and price information
  products: [Product!]!
  viewer: User!

  # Find a persistent volume by ID
  volume(id: ID!): Volume
}

type Region {
  # The IATA airport code for this region
  code: String!
  gatewayAvailable: Boolean!

  # The latitude of this region
  latitude: Float

  # The longitude of this region
  longitude: Float

  # The name of this region
  name: String!
  processGroup: String
}

enum RegionEnum {
  # Amsterdam, NL
  AMS

  # Atlanta, US
  ATL

  # Dallas, US
  DFW

  # New York, US
  EWR

  # Frankfurt, DE
  FRA

  # Hong Kong, CN
  HKG

  # Virginia, US
  IAD

  # Los Angeles, US
  LAX

  # Tokyo, JP
  NRT

  # Chicago, US
  ORD

  # Seattle, US
  SEA

  # Singapore, SG
  SIN

  # San Jose, US
  SJC

  # Sydney, AU
  SYD

  # Toronto, CA
  YYZ
}

type RegionPlacement {
  # The desired number of allocations
  count: Int

  # The region code
  region: String!
}

# Autogenerated input type of RegisterDomain
input RegisterDomainInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the domain
  domainId: ID!

  # Enable whois privacy on the registration
  whoisPrivacy: Boolean

  # Enable auto renew on the registration
  autoRenew: Boolean
}

# Autogenerated return type of RegisterDomain
type RegisterDomainPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  domain: Domain!
}

type Release implements Node {
  config: AppConfig
  createdAt: ISO8601DateTime!
  deploymentStrategy: DeploymentStrategy!

  # A description of the release
  description: String!
  evaluationId: String

  # Unique ID
  id: ID!

  # Docker image
  image: Image

  # Docker image URI
  imageRef: String
  inProgress: Boolean! @deprecated(reason: "use deployment.inProgress")

  # The reason for the release
  reason: String!

  # Version release reverted to
  revertedTo: Int
  stable: Boolean!

  # The status of the release
  status: String!
  updatedAt: ISO8601DateTime!

  # The user who created the release
  user: User

  # The version of the release
  version: Int!
}

type ReleaseCommand implements Node {
  app: App!
  command: String!
  evaluationId: String
  exitCode: Int
  failed: Boolean!
  id: ID!
  inProgress: Boolean!
  instanceId: String
  status: String!
  succeeded: Boolean!
}

# The connection type for Release.
type ReleaseConnection {
  # A list of edges.
  edges: [ReleaseEdge]

  # A list of nodes.
  nodes: [Release]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type ReleaseEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Release
}

# Autogenerated input type of ReleaseIPAddress
input ReleaseIPAddressInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The id of the ip address to release
  ipAddressId: ID!
}

# Autogenerated return type of ReleaseIPAddress
type ReleaseIPAddressPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

type RemoteDockerBuilderAppRole implements AppRole {
  # The name of this role
  name: String!
}

# Autogenerated input type of RemoveMachine
input RemoveMachineInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID

  # machine id
  id: String!

  # force kill machine if it's running
  kill: Boolean
}

# Autogenerated return type of RemoveMachine
type RemoveMachinePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  machine: Machine!
}

# Autogenerated input type of RemoveWireGuardPeer
input RemoveWireGuardPeerInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The name of the peer to remove
  name: String!

  # Add via NATS transaction (for testing only, nosy users)
  nats: Boolean
}

# Autogenerated return type of RemoveWireGuardPeer
type RemoveWireGuardPeerPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The organization that owned the peer
  organization: Organization!
}

# Autogenerated input type of RestartAllocation
input RestartAllocationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # The ID of the app
  allocId: ID!
}

# Autogenerated return type of RestartAllocation
type RestartAllocationPayload {
  allocation: Allocation!
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of RestartApp
input RestartAppInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!
}

# Autogenerated return type of RestartApp
type RestartAppPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of RestoreVolumeSnapshot
input RestoreVolumeSnapshotInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  volumeId: ID!
  snapshotId: ID!
}

# Autogenerated return type of RestoreVolumeSnapshot
type RestoreVolumeSnapshotPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  snapshot: VolumeSnapshot!
  volume: Volume!
}

# Autogenerated input type of ResumeApp
input ResumeAppInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!
}

# Autogenerated return type of ResumeApp
type ResumeAppPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of RevokePostgresClusterUserAccess
input RevokePostgresClusterUserAccessInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The name of the postgres cluster app
  appName: String!

  # The username to revoke
  username: String!

  # The database to revoke access to
  databaseName: String!
}

# Autogenerated return type of RevokePostgresClusterUserAccess
type RevokePostgresClusterUserAccessPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  database: PostgresClusterDatabase!
  postgresClusterRole: PostgresClusterAppRole!
  user: PostgresClusterUser!
}

enum RuntimeType {
  # Fly Container Runtime
  FIRECRACKER

  # Fly JavaScript Runtime
  NODEPROXY
}

# Autogenerated input type of SaveDeploymentSource
input SaveDeploymentSourceInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The application to update
  appId: String!
  provider: String!
  repositoryId: String!
  ref: String
  baseDir: String
  skipBuild: Boolean
}

# Autogenerated return type of SaveDeploymentSource
type SaveDeploymentSourcePayload {
  app: App
  build: Build

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of ScaleApp
input ScaleAppInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # Regions to scale
  regions: [ScaleRegionInput!]!
}

# Autogenerated return type of ScaleApp
type ScaleAppPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  delta: [ScaleRegionChange!]!
  placement: [RegionPlacement!]!
}

type ScaleRegionChange {
  # The original value
  fromCount: Int!

  # The region code
  region: String!

  # The new value
  toCount: Int
}

# Region placement configuration
input ScaleRegionInput {
  # The region to configure
  region: String!

  # The value to change by
  count: Int!
}

enum SchedulingEnum {
  # Permanent app, restarts on exit
  PERMANENT

  # Ephemeral app, stays stopped on exit
  EPHEMERAL
}

type Secret implements Node {
  createdAt: ISO8601DateTime!

  # The digest of the secret value
  digest: String!
  id: ID!

  # The name of the secret
  name: String!

  # The user who initiated the deployment
  user: User
}

# A secure configuration value
input SecretInput {
  # The unqiue key for this secret
  key: String!

  # The value of this secret
  value: String!
}

# Global port routing
type Service {
  # Health checks
  checks: [Check!]!
  description: String!

  # Hard concurrency limit
  hardConcurrency: Int!

  # Application port to forward traffic to
  internalPort: Int!

  # Ports to listen on
  ports: [ServicePort!]!

  # Protocol to listen on
  protocol: ServiceProtocolType!

  # Soft concurrency limit
  softConcurrency: Int!
}

enum ServiceHandlerType {
  # Convert TLS connection to unencrypted TCP
  TLS

  # Convert TCP connection to HTTP
  HTTP

  # Convert TCP connection to HTTP (at the edge)
  EDGE_HTTP

  # Wrap TCP connection in PROXY protocol
  PROXY_PROTO
}

# Global port routing
input ServiceInput {
  # Protocol to listen on
  protocol: ServiceProtocolType!

  # Ports to listen on
  ports: [ServiceInputPort!]

  # Application port to forward traffic to
  internalPort: Int!

  # Health checks
  checks: [CheckInput!]

  # Soft concurrency limit
  softConcurrency: Int

  # Hard concurrency limit
  hardConcurrency: Int
}

# Service port
input ServiceInputPort {
  # Port to listen on
  port: Int!

  # Handlers to apply before forwarding service traffic
  handlers: [ServiceHandlerType!]

  # tls options
  tlsOptions: ServicePortTlsOptionsInput
}

# Service port
type ServicePort {
  # Handlers to apply before forwarding service traffic
  handlers: [ServiceHandlerType!]!

  # Port to listen on
  port: Int!
}

# TLS handshakes options for a port
input ServicePortTlsOptionsInput {
  defaultSelfSigned: Boolean
}

enum ServiceProtocolType {
  # TCP protocol
  TCP

  # UDP protocl
  UDP
}

# Autogenerated input type of SetPagerdutyHandler
input SetPagerdutyHandlerInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # Handler name
  name: String!

  # PagerDuty API token
  pagerdutyToken: String!

  # Map of alert severity levels to PagerDuty severity levels
  pagerdutyStatusMap: JSON
}

# Autogenerated return type of SetPagerdutyHandler
type SetPagerdutyHandlerPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  handler: HealthCheckHandler!
}

# Autogenerated input type of SetSecrets
input SetSecretsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # Secrets to set
  secrets: [SecretInput!]!

  # By default, we set only the secrets you specify. Set this to true to replace all secrets.
  replaceAll: Boolean
}

# Autogenerated return type of SetSecrets
type SetSecretsPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  release: Release
}

# Autogenerated input type of SetSlackHandler
input SetSlackHandlerInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # Handler name
  name: String!

  # Slack Webhook URL to use for health check notifications
  slackWebhookUrl: String!

  # Slack channel to send messages to, defaults to #general
  slackChannel: String

  # User name to display on Slack Messages (defaults to Fly)
  slackUsername: String

  # Icon to show with Slack messages
  slackIconUrl: String
}

# Autogenerated return type of SetSlackHandler
type SetSlackHandlerPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  handler: HealthCheckHandler!
}

# Autogenerated input type of SetVMCount
input SetVMCountInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # Counts for VM groups
  groupCounts: [VMCountInput!]!
}

# Autogenerated return type of SetVMCount
type SetVMCountPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  release: Release
  taskGroupCounts: [TaskGroupCount!]!
  warnings: [String!]!
}

# Autogenerated input type of SetVMSize
input SetVMSizeInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # The name of the vm size to set
  sizeName: String!

  # Optionally request more memory
  memoryMb: Int

  # Process group to modify
  group: String
}

# Autogenerated return type of SetVMSize
type SetVMSizePayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Process Group scale change applied to (if any)
  processGroup: ProcessGroup

  # Default app vm size
  vmSize: VMSize
}

type SourceBuild implements Node {
  app: App!
  createdAt: ISO8601DateTime!

  # The user who initiated the build
  createdBy: User
  id: ID!
  image: String

  # Log output
  logs: String

  # Status of the build
  status: String!
  updatedAt: ISO8601DateTime!
}

# The connection type for SourceBuild.
type SourceBuildConnection {
  # A list of edges.
  edges: [SourceBuildEdge]

  # A list of nodes.
  nodes: [SourceBuild]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type SourceBuildEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: SourceBuild
}

# Autogenerated input type of StartBuild
input StartBuildInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!
}

# Autogenerated return type of StartBuild
type StartBuildPayload {
  build: Build!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of StartMachine
input StartMachineInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID

  # machine id
  id: String!
}

# Autogenerated return type of StartMachine
type StartMachinePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  machine: Machine!
}

# Autogenerated input type of StopAllocation
input StopAllocationInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # The ID of the app
  allocId: ID!
}

# Autogenerated return type of StopAllocation
type StopAllocationPayload {
  allocation: Allocation!
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of StopMachine
input StopMachineInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID

  # machine id
  id: String!

  # signal to send the machine
  signal: String

  # how long to wait before force killing the machine
  killTimeoutSecs: Int
}

# Autogenerated return type of StopMachine
type StopMachinePayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  machine: Machine!
}

type TaskGroupCount {
  count: Int!
  name: String!
}

type TemplateDeployment implements Node {
  apps(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): AppConnection!
  id: ID!
  organization: Organization!
  status: String!
}

# Autogenerated input type of UnsetSecrets
input UnsetSecretsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!

  # Secret keys to unset
  keys: [String!]!
}

# Autogenerated return type of UnsetSecrets
type UnsetSecretsPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  release: Release
}

# Autogenerated input type of UpdateAutoscaleConfig
input UpdateAutoscaleConfigInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The ID of the app
  appId: ID!
  enabled: Boolean
  minCount: Int
  maxCount: Int
  balanceRegions: Boolean

  # Region configs
  regions: [AutoscaleRegionConfigInput!]
  resetRegions: Boolean
}

# Autogenerated return type of UpdateAutoscaleConfig
type UpdateAutoscaleConfigPayload {
  app: App!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
}

# Autogenerated input type of UpdateBuild
input UpdateBuildInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # Build ID
  recordId: ID!

  # The plaintext build output
  logs: String

  # The build status
  status: String
}

# Autogenerated return type of UpdateBuild
type UpdateBuildPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  sourceBuild: SourceBuild!
}

# Autogenerated input type of UpdateDNSPortal
input UpdateDNSPortalInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  dnsPortalId: ID!

  # The unique name of this portal.
  name: String

  # The title of this portal
  title: String

  # The return url for this portal
  returnUrl: String

  # The text to display for the return url link
  returnUrlText: String

  # The support url for this portal
  supportUrl: String

  # The text to display for the support url link
  supportUrlText: String

  # The primary branding color
  primaryColor: String

  # The secondary branding color
  accentColor: String
}

# Autogenerated return type of UpdateDNSPortal
type UpdateDNSPortalPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  dnsPortal: DNSPortal!
}

# Autogenerated input type of UpdateDNSRecord
input UpdateDNSRecordInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the DNS record
  recordId: ID!

  # The dns record name
  name: String

  # The TTL in seconds
  ttl: Int

  # The content of the record
  rdata: String
}

# Autogenerated return type of UpdateDNSRecord
type UpdateDNSRecordPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  record: DNSRecord!
}

# Autogenerated input type of UpdateDNSRecords
input UpdateDNSRecordsInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the domain
  domainId: ID!
  changes: [DNSRecordChangeInput!]!
}

# Autogenerated return type of UpdateDNSRecords
type UpdateDNSRecordsPayload {
  changes: [DNSRecordDiff!]!

  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  domain: Domain!
  warnings: [DNSRecordWarning!]!
}

# Autogenerated input type of UpdateOrganizationMembership
input UpdateOrganizationMembershipInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # The node ID of the user
  userId: ID!

  # The new role for the user
  role: OrganizationMemberRole!
}

# Autogenerated return type of UpdateOrganizationMembership
type UpdateOrganizationMembershipPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  organization: Organization!
  user: User!
}

# Autogenerated input type of UpdateRemoteBuilder
input UpdateRemoteBuilderInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String

  # The node ID of the organization
  organizationId: ID!

  # Docker image reference
  image: String!
}

# Autogenerated return type of UpdateRemoteBuilder
type UpdateRemoteBuilderPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  organization: Organization!
}

type User implements Node {
  # URL for avatar or placeholder
  avatarUrl: String!
  createdAt: ISO8601DateTime!

  # Email address for user (private)
  email: String!
  featureFlags: [String!]!
  hasNodeproxyApps: Boolean!
  id: ID!
  lastRegion: String

  # Display / full name for user (private)
  name: String
  organizations(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): OrganizationConnection!
    @deprecated(reason: "Use query.organizations instead")
  personalOrganization: Organization!
    @deprecated(reason: "Use query.personalOrganization instead")
  trust: OrganizationTrust!
  twoFactorProtection: Boolean!

  # Public username for user
  username: String
}

type VM implements Node {
  attachedVolumes(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): VolumeConnection!
  canary: Boolean!
  checks(
    # Filter checks by name
    name: String
  ): [CheckState!]!
  createdAt: ISO8601DateTime!
  criticalCheckCount: Int!

  # Desired status
  desiredStatus: String!
  events: [AllocationEvent!]!
  failed: Boolean!
  healthy: Boolean!

  # Unique ID for this instance
  id: ID!

  # Short unique ID for this instance
  idShort: ID!

  # Indicates if this instance is from the latest job version
  latestVersion: Boolean!
  passingCheckCount: Int!

  # Private IPv6 address for this instance
  privateIP: String
  recentLogs(
    # Max number of entries to return
    limit: Int = 10

    # Max age of log entries in seconds
    range: Int = 300
  ): [LogEntry!]!

  # Region this allocation is running in
  region: String!
  restarts: Int!

  # Current status
  status: String!
  taskName: String!
  totalCheckCount: Int!
  transitioning: Boolean!
  updatedAt: ISO8601DateTime!

  # The configuration version of this instance
  version: Int!
  warningCheckCount: Int!
}

# The connection type for VM.
type VMConnection {
  activeCount: Int!
  completeCount: Int!

  # A list of edges.
  edges: [VMEdge]
  failedCount: Int!
  inactiveCount: Int!
  lostCount: Int!

  # A list of nodes.
  nodes: [VM]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  pendingCount: Int!
  runningCount: Int!
  totalCount: Int!
}

input VMCountInput {
  # VM group name
  group: String

  # The desired count
  count: Int

  # Max number of VMs to allow per region
  maxPerRegion: Int
}

# An edge in a connection.
type VMEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: VM
}

type VMSize {
  cpuCores: Float!
  maxMemoryMb: Int!
  memoryGb: Float!
  memoryIncrementsMb: [Int!]!
  memoryMb: Int!
  name: String!
  priceMonth: Float!
  priceSecond: Float!
}

enum VMSizeEnum {
  # Shared 1x CPU core, 256MB
  SHARED_CPU_1X

  # Dedicated 1x CPU core, 2GB
  DEDICATED_CPU_1X

  # Dedicated 2x CPU core, 4GB
  DEDICATED_CPU_2X

  # Dedicated 4x CPU core, 8GB
  DEDICATED_CPU_4X

  # Dedicated 8x CPU core, 16GB
  DEDICATED_CPU_8X
}

# Autogenerated input type of ValidateWireGuardPeers
input ValidateWireGuardPeersInput {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  peerIps: [String!]!
}

# Autogenerated return type of ValidateWireGuardPeers
type ValidateWireGuardPeersPayload {
  # A unique identifier for the client performing the mutation.
  clientMutationId: String
  invalidPeerIps: [String!]!
  validPeerIps: [String!]!
}

type Volume implements Node {
  app: App!
  attachedAllocation: Allocation
  createdAt: ISO8601DateTime!
  encrypted: Boolean!
  host: Host!
  id: ID!
  internalId: String!
  name: String!
  region: String!
  sizeGb: Int!
  snapshots(
    # Returns the elements in the list that come after the specified cursor.
    after: String

    # Returns the elements in the list that come before the specified cursor.
    before: String

    # Returns the first _n_ elements from the list.
    first: Int

    # Returns the last _n_ elements from the list.
    last: Int
  ): VolumeSnapshotConnection!
  state: String!
  status: String!
  usedBytes: BigInt!
}

# The connection type for Volume.
type VolumeConnection {
  # A list of edges.
  edges: [VolumeEdge]

  # A list of nodes.
  nodes: [Volume]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type VolumeEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: Volume
}

input VolumeInput {
  # Volume name
  name: String!

  # Desired region for volume
  region: RegionEnum!

  # Desired volume size, in GB
  sizeGb: Int!

  # Volume should be encrypted at rest
  encrypted: Boolean

  # How many volumes to create with this configuration
  count: Int = 1
}

type VolumeSnapshot implements Node {
  createdAt: ISO8601DateTime!
  digest: String!
  id: ID!
  size: BigInt!
  volume: Volume!
}

# The connection type for VolumeSnapshot.
type VolumeSnapshotConnection {
  # A list of edges.
  edges: [VolumeSnapshotEdge]

  # A list of nodes.
  nodes: [VolumeSnapshot]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type VolumeSnapshotEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: VolumeSnapshot
}

type WireGuardPeer implements Node {
  gatewayStatus: JSON!
  id: ID!
  name: String!
  network: String
  peerip: String!
  pubkey: String!
  region: String!
}

# The connection type for WireGuardPeer.
type WireGuardPeerConnection {
  # A list of edges.
  edges: [WireGuardPeerEdge]

  # A list of nodes.
  nodes: [WireGuardPeer]

  # Information to aid in pagination.
  pageInfo: PageInfo!
  totalCount: Int!
}

# An edge in a connection.
type WireGuardPeerEdge {
  # A cursor for use in pagination.
  cursor: String!

  # The item at the end of the edge.
  node: WireGuardPeer
}
